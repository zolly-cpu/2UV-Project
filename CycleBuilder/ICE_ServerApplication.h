//
// Copyright (c) ZeroC, Inc. All rights reserved.
//
//
// Ice version 3.7.10
//
// <auto-generated>
//
// Generated from file `ICE_ServerApplication.ice'
//
// Warning: do not edit this file.
//
// </auto-generated>
//

#ifndef __ICE_ServerApplication_h__
#define __ICE_ServerApplication_h__

#include <IceUtil/PushDisableWarnings.h>
#include <Ice/ProxyF.h>
#include <Ice/ObjectF.h>
#include <Ice/ValueF.h>
#include <Ice/Exception.h>
#include <Ice/LocalObject.h>
#include <Ice/StreamHelpers.h>
#include <Ice/Comparable.h>
#include <Ice/Proxy.h>
#include <Ice/Object.h>
#include <Ice/GCObject.h>
#include <Ice/Value.h>
#include <Ice/Incoming.h>
#include <Ice/FactoryTableInit.h>
#include <IceUtil/ScopedArray.h>
#include <Ice/Optional.h>
#include <IceUtil/UndefSysMacros.h>

#ifndef ICE_IGNORE_VERSION
#   if ICE_INT_VERSION / 100 != 307
#       error Ice version mismatch!
#   endif
#   if ICE_INT_VERSION % 100 >= 50
#       error Beta header file detected
#   endif
#   if ICE_INT_VERSION % 100 < 10
#       error Ice patch level mismatch!
#   endif
#endif

#ifdef ICE_CPP11_MAPPING // C++11 mapping

namespace UVServerAppServer
{

class ServerAppServer;
class ServerAppServerPrx;

}

namespace UVServerAppServer
{

using tyStringSequence = ::std::vector<::std::string>;

}

namespace UVServerAppServer
{

class ServerAppServer : public virtual ::Ice::Object
{
public:

    using ProxyType = ServerAppServerPrx;

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(::std::string id, const ::Ice::Current& current) const override;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector<::std::string> ice_ids(const ::Ice::Current& current) const override;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual ::std::string ice_id(const ::Ice::Current& current) const override;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual bool Ping(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_Ping(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void Shutdown(const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_Shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to insertIntoTableDatabase.
     */
    struct InsertIntoTableDatabaseResult
    {
        bool returnValue;
        ::std::string paReturnMessage;
    };

    virtual bool insertIntoTableDatabase(::std::string paTableName, tyStringSequence paColumns, tyStringSequence paValue, tyStringSequence paTypeValue, ::std::string& paReturnMessage, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_insertIntoTableDatabase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to updateIntoTableDatabase.
     */
    struct UpdateIntoTableDatabaseResult
    {
        bool returnValue;
        ::std::string paReturnMessage;
    };

    virtual bool updateIntoTableDatabase(::std::string paTableName, ::std::string paId, tyStringSequence paColumns, tyStringSequence paValue, tyStringSequence paTypeValue, ::std::string& paReturnMessage, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_updateIntoTableDatabase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to deleteIntoTableDatabase.
     */
    struct DeleteIntoTableDatabaseResult
    {
        bool returnValue;
        ::std::string paReturnMessage;
    };

    virtual bool deleteIntoTableDatabase(::std::string paTableName, ::std::string paId, ::std::string& paReturnMessage, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_deleteIntoTableDatabase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to getFromTableDatabaseGeneral.
     */
    struct GetFromTableDatabaseGeneralResult
    {
        bool returnValue;
        tyStringSequence paReturnId;
        tyStringSequence paReturnName;
        ::std::string paMessage;
    };

    virtual bool getFromTableDatabaseGeneral(::std::string paTableName, ::std::string paStartValue, ::std::string paMaxValue, tyStringSequence& paReturnId, tyStringSequence& paReturnName, ::std::string& paMessage, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getFromTableDatabaseGeneral(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to getFromTableDatbaseByProperty.
     */
    struct GetFromTableDatbaseByPropertyResult
    {
        bool returnValue;
        tyStringSequence paReturnId;
        ::std::string paReturnMessage;
    };

    virtual bool getFromTableDatbaseByProperty(::std::string paTableName, ::std::string paStartValue, ::std::string paMaxValue, tyStringSequence paProperties, tyStringSequence paValue, tyStringSequence paTypeValue, tyStringSequence paLogExp, tyStringSequence& paReturnId, ::std::string& paReturnMessage, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getFromTableDatbaseByProperty(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to getFromTableDatabaseById.
     */
    struct GetFromTableDatabaseByIdResult
    {
        bool returnValue;
        tyStringSequence paReturnValue;
        ::std::string paReturnMessage;
    };

    virtual bool getFromTableDatabaseById(::std::string paTableName, ::std::string paId, tyStringSequence paProperties, tyStringSequence& paReturnValue, ::std::string& paReturnMessage, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getFromTableDatabaseById(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to getAllTablesFromDatabase.
     */
    struct GetAllTablesFromDatabaseResult
    {
        bool returnValue;
        tyStringSequence paTables;
        ::std::string paReturnMessage;
    };

    virtual bool getAllTablesFromDatabase(tyStringSequence& paTables, ::std::string& paReturnMessage, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getAllTablesFromDatabase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to getAllMethodsFromTable.
     */
    struct GetAllMethodsFromTableResult
    {
        bool returnValue;
        tyStringSequence paMethodName;
        tyStringSequence paAlias;
        tyStringSequence paSource;
        tyStringSequence paSourceName;
        tyStringSequence paReturnType;
        ::std::string paReturnMessage;
    };

    virtual bool getAllMethodsFromTable(::std::string paTable, tyStringSequence& paMethodName, tyStringSequence& paAlias, tyStringSequence& paSource, tyStringSequence& paSourceName, tyStringSequence& paReturnType, ::std::string& paReturnMessage, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getAllMethodsFromTable(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to getAllPropertiesFromTable.
     */
    struct GetAllPropertiesFromTableResult
    {
        bool returnValue;
        tyStringSequence paPropertyName;
        tyStringSequence paAlias;
        tyStringSequence paType;
        tyStringSequence paExtra;
        tyStringSequence paReference;
        ::std::string paReturnMessage;
    };

    virtual bool getAllPropertiesFromTable(::std::string paTable, tyStringSequence& paPropertyName, tyStringSequence& paAlias, tyStringSequence& paType, tyStringSequence& paExtra, tyStringSequence& paReference, ::std::string& paReturnMessage, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_getAllPropertiesFromTable(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /**
     * Encapsulates the results of a call to giveWorkstationClientInfo.
     */
    struct GiveWorkstationClientInfoResult
    {
        bool returnValue;
        ::std::string paReturnMessage;
    };

    virtual bool giveWorkstationClientInfo(::std::string paWorkstationName, ::std::string paPercentageMemUsage, ::std::string paPercentageDiskUsage, ::std::string paPercentageCpuUsage, ::std::string& paReturnMessage, const ::Ice::Current& current) = 0;
    /// \cond INTERNAL
    bool _iceD_giveWorkstationClientInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&) override;
    /// \endcond
};

}

namespace UVServerAppServer
{

class ServerAppServerPrx : public virtual ::Ice::Proxy<ServerAppServerPrx, ::Ice::ObjectPrx>
{
public:

    bool Ping(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makePromiseOutgoing<bool>(true, this, &ServerAppServerPrx::_iceI_Ping, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto PingAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<bool>>().get_future())
    {
        return _makePromiseOutgoing<bool, P>(false, this, &ServerAppServerPrx::_iceI_Ping, context);
    }

    ::std::function<void()>
    PingAsync(::std::function<void(bool)> response,
              ::std::function<void(::std::exception_ptr)> ex = nullptr,
              ::std::function<void(bool)> sent = nullptr,
              const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<bool>(std::move(response), std::move(ex), std::move(sent), this, &UVServerAppServer::ServerAppServerPrx::_iceI_Ping, context);
    }

    /// \cond INTERNAL
    void _iceI_Ping(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<bool>>&, const ::Ice::Context&);
    /// \endcond

    void Shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        _makePromiseOutgoing<void>(true, this, &ServerAppServerPrx::_iceI_Shutdown, context).get();
    }

    template<template<typename> class P = ::std::promise>
    auto ShutdownAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<void>>().get_future())
    {
        return _makePromiseOutgoing<void, P>(false, this, &ServerAppServerPrx::_iceI_Shutdown, context);
    }

    ::std::function<void()>
    ShutdownAsync(::std::function<void()> response,
                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                  ::std::function<void(bool)> sent = nullptr,
                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _makeLamdaOutgoing<void>(std::move(response), std::move(ex), std::move(sent), this, &UVServerAppServer::ServerAppServerPrx::_iceI_Shutdown, context);
    }

    /// \cond INTERNAL
    void _iceI_Shutdown(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<void>>&, const ::Ice::Context&);
    /// \endcond

    bool insertIntoTableDatabase(const ::std::string& paTableName, const tyStringSequence& paColumns, const tyStringSequence& paValue, const tyStringSequence& paTypeValue, ::std::string& paReturnMessage, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ServerAppServer::InsertIntoTableDatabaseResult>(true, this, &ServerAppServerPrx::_iceI_insertIntoTableDatabase, paTableName, paColumns, paValue, paTypeValue, context).get();
        paReturnMessage = ::std::move(_result.paReturnMessage);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto insertIntoTableDatabaseAsync(const ::std::string& paTableName, const tyStringSequence& paColumns, const tyStringSequence& paValue, const tyStringSequence& paTypeValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ServerAppServer::InsertIntoTableDatabaseResult>>().get_future())
    {
        return _makePromiseOutgoing<ServerAppServer::InsertIntoTableDatabaseResult, P>(false, this, &ServerAppServerPrx::_iceI_insertIntoTableDatabase, paTableName, paColumns, paValue, paTypeValue, context);
    }

    ::std::function<void()>
    insertIntoTableDatabaseAsync(const ::std::string& paTableName, const tyStringSequence& paColumns, const tyStringSequence& paValue, const tyStringSequence& paTypeValue,
                                 ::std::function<void(bool, ::std::string)> response,
                                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                 ::std::function<void(bool)> sent = nullptr,
                                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ServerAppServer::InsertIntoTableDatabaseResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.paReturnMessage));
        };
        return _makeLamdaOutgoing<ServerAppServer::InsertIntoTableDatabaseResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &UVServerAppServer::ServerAppServerPrx::_iceI_insertIntoTableDatabase, paTableName, paColumns, paValue, paTypeValue, context);
    }

    /// \cond INTERNAL
    void _iceI_insertIntoTableDatabase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ServerAppServer::InsertIntoTableDatabaseResult>>&, const ::std::string&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const ::Ice::Context&);
    /// \endcond

    bool updateIntoTableDatabase(const ::std::string& paTableName, const ::std::string& paId, const tyStringSequence& paColumns, const tyStringSequence& paValue, const tyStringSequence& paTypeValue, ::std::string& paReturnMessage, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ServerAppServer::UpdateIntoTableDatabaseResult>(true, this, &ServerAppServerPrx::_iceI_updateIntoTableDatabase, paTableName, paId, paColumns, paValue, paTypeValue, context).get();
        paReturnMessage = ::std::move(_result.paReturnMessage);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto updateIntoTableDatabaseAsync(const ::std::string& paTableName, const ::std::string& paId, const tyStringSequence& paColumns, const tyStringSequence& paValue, const tyStringSequence& paTypeValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ServerAppServer::UpdateIntoTableDatabaseResult>>().get_future())
    {
        return _makePromiseOutgoing<ServerAppServer::UpdateIntoTableDatabaseResult, P>(false, this, &ServerAppServerPrx::_iceI_updateIntoTableDatabase, paTableName, paId, paColumns, paValue, paTypeValue, context);
    }

    ::std::function<void()>
    updateIntoTableDatabaseAsync(const ::std::string& paTableName, const ::std::string& paId, const tyStringSequence& paColumns, const tyStringSequence& paValue, const tyStringSequence& paTypeValue,
                                 ::std::function<void(bool, ::std::string)> response,
                                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                 ::std::function<void(bool)> sent = nullptr,
                                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ServerAppServer::UpdateIntoTableDatabaseResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.paReturnMessage));
        };
        return _makeLamdaOutgoing<ServerAppServer::UpdateIntoTableDatabaseResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &UVServerAppServer::ServerAppServerPrx::_iceI_updateIntoTableDatabase, paTableName, paId, paColumns, paValue, paTypeValue, context);
    }

    /// \cond INTERNAL
    void _iceI_updateIntoTableDatabase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ServerAppServer::UpdateIntoTableDatabaseResult>>&, const ::std::string&, const ::std::string&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const ::Ice::Context&);
    /// \endcond

    bool deleteIntoTableDatabase(const ::std::string& paTableName, const ::std::string& paId, ::std::string& paReturnMessage, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ServerAppServer::DeleteIntoTableDatabaseResult>(true, this, &ServerAppServerPrx::_iceI_deleteIntoTableDatabase, paTableName, paId, context).get();
        paReturnMessage = ::std::move(_result.paReturnMessage);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto deleteIntoTableDatabaseAsync(const ::std::string& paTableName, const ::std::string& paId, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ServerAppServer::DeleteIntoTableDatabaseResult>>().get_future())
    {
        return _makePromiseOutgoing<ServerAppServer::DeleteIntoTableDatabaseResult, P>(false, this, &ServerAppServerPrx::_iceI_deleteIntoTableDatabase, paTableName, paId, context);
    }

    ::std::function<void()>
    deleteIntoTableDatabaseAsync(const ::std::string& paTableName, const ::std::string& paId,
                                 ::std::function<void(bool, ::std::string)> response,
                                 ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                 ::std::function<void(bool)> sent = nullptr,
                                 const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ServerAppServer::DeleteIntoTableDatabaseResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.paReturnMessage));
        };
        return _makeLamdaOutgoing<ServerAppServer::DeleteIntoTableDatabaseResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &UVServerAppServer::ServerAppServerPrx::_iceI_deleteIntoTableDatabase, paTableName, paId, context);
    }

    /// \cond INTERNAL
    void _iceI_deleteIntoTableDatabase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ServerAppServer::DeleteIntoTableDatabaseResult>>&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    bool getFromTableDatabaseGeneral(const ::std::string& paTableName, const ::std::string& paStartValue, const ::std::string& paMaxValue, tyStringSequence& paReturnId, tyStringSequence& paReturnName, ::std::string& paMessage, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ServerAppServer::GetFromTableDatabaseGeneralResult>(true, this, &ServerAppServerPrx::_iceI_getFromTableDatabaseGeneral, paTableName, paStartValue, paMaxValue, context).get();
        paReturnId = ::std::move(_result.paReturnId);
        paReturnName = ::std::move(_result.paReturnName);
        paMessage = ::std::move(_result.paMessage);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getFromTableDatabaseGeneralAsync(const ::std::string& paTableName, const ::std::string& paStartValue, const ::std::string& paMaxValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ServerAppServer::GetFromTableDatabaseGeneralResult>>().get_future())
    {
        return _makePromiseOutgoing<ServerAppServer::GetFromTableDatabaseGeneralResult, P>(false, this, &ServerAppServerPrx::_iceI_getFromTableDatabaseGeneral, paTableName, paStartValue, paMaxValue, context);
    }

    ::std::function<void()>
    getFromTableDatabaseGeneralAsync(const ::std::string& paTableName, const ::std::string& paStartValue, const ::std::string& paMaxValue,
                                     ::std::function<void(bool, ::UVServerAppServer::tyStringSequence, ::UVServerAppServer::tyStringSequence, ::std::string)> response,
                                     ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                     ::std::function<void(bool)> sent = nullptr,
                                     const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ServerAppServer::GetFromTableDatabaseGeneralResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.paReturnId), ::std::move(_result.paReturnName), ::std::move(_result.paMessage));
        };
        return _makeLamdaOutgoing<ServerAppServer::GetFromTableDatabaseGeneralResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &UVServerAppServer::ServerAppServerPrx::_iceI_getFromTableDatabaseGeneral, paTableName, paStartValue, paMaxValue, context);
    }

    /// \cond INTERNAL
    void _iceI_getFromTableDatabaseGeneral(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ServerAppServer::GetFromTableDatabaseGeneralResult>>&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    bool getFromTableDatbaseByProperty(const ::std::string& paTableName, const ::std::string& paStartValue, const ::std::string& paMaxValue, const tyStringSequence& paProperties, const tyStringSequence& paValue, const tyStringSequence& paTypeValue, const tyStringSequence& paLogExp, tyStringSequence& paReturnId, ::std::string& paReturnMessage, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ServerAppServer::GetFromTableDatbaseByPropertyResult>(true, this, &ServerAppServerPrx::_iceI_getFromTableDatbaseByProperty, paTableName, paStartValue, paMaxValue, paProperties, paValue, paTypeValue, paLogExp, context).get();
        paReturnId = ::std::move(_result.paReturnId);
        paReturnMessage = ::std::move(_result.paReturnMessage);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getFromTableDatbaseByPropertyAsync(const ::std::string& paTableName, const ::std::string& paStartValue, const ::std::string& paMaxValue, const tyStringSequence& paProperties, const tyStringSequence& paValue, const tyStringSequence& paTypeValue, const tyStringSequence& paLogExp, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ServerAppServer::GetFromTableDatbaseByPropertyResult>>().get_future())
    {
        return _makePromiseOutgoing<ServerAppServer::GetFromTableDatbaseByPropertyResult, P>(false, this, &ServerAppServerPrx::_iceI_getFromTableDatbaseByProperty, paTableName, paStartValue, paMaxValue, paProperties, paValue, paTypeValue, paLogExp, context);
    }

    ::std::function<void()>
    getFromTableDatbaseByPropertyAsync(const ::std::string& paTableName, const ::std::string& paStartValue, const ::std::string& paMaxValue, const tyStringSequence& paProperties, const tyStringSequence& paValue, const tyStringSequence& paTypeValue, const tyStringSequence& paLogExp,
                                       ::std::function<void(bool, ::UVServerAppServer::tyStringSequence, ::std::string)> response,
                                       ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                       ::std::function<void(bool)> sent = nullptr,
                                       const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ServerAppServer::GetFromTableDatbaseByPropertyResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.paReturnId), ::std::move(_result.paReturnMessage));
        };
        return _makeLamdaOutgoing<ServerAppServer::GetFromTableDatbaseByPropertyResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &UVServerAppServer::ServerAppServerPrx::_iceI_getFromTableDatbaseByProperty, paTableName, paStartValue, paMaxValue, paProperties, paValue, paTypeValue, paLogExp, context);
    }

    /// \cond INTERNAL
    void _iceI_getFromTableDatbaseByProperty(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ServerAppServer::GetFromTableDatbaseByPropertyResult>>&, const ::std::string&, const ::std::string&, const ::std::string&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const ::Ice::Context&);
    /// \endcond

    bool getFromTableDatabaseById(const ::std::string& paTableName, const ::std::string& paId, const tyStringSequence& paProperties, tyStringSequence& paReturnValue, ::std::string& paReturnMessage, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ServerAppServer::GetFromTableDatabaseByIdResult>(true, this, &ServerAppServerPrx::_iceI_getFromTableDatabaseById, paTableName, paId, paProperties, context).get();
        paReturnValue = ::std::move(_result.paReturnValue);
        paReturnMessage = ::std::move(_result.paReturnMessage);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getFromTableDatabaseByIdAsync(const ::std::string& paTableName, const ::std::string& paId, const tyStringSequence& paProperties, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ServerAppServer::GetFromTableDatabaseByIdResult>>().get_future())
    {
        return _makePromiseOutgoing<ServerAppServer::GetFromTableDatabaseByIdResult, P>(false, this, &ServerAppServerPrx::_iceI_getFromTableDatabaseById, paTableName, paId, paProperties, context);
    }

    ::std::function<void()>
    getFromTableDatabaseByIdAsync(const ::std::string& paTableName, const ::std::string& paId, const tyStringSequence& paProperties,
                                  ::std::function<void(bool, ::UVServerAppServer::tyStringSequence, ::std::string)> response,
                                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                  ::std::function<void(bool)> sent = nullptr,
                                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ServerAppServer::GetFromTableDatabaseByIdResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.paReturnValue), ::std::move(_result.paReturnMessage));
        };
        return _makeLamdaOutgoing<ServerAppServer::GetFromTableDatabaseByIdResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &UVServerAppServer::ServerAppServerPrx::_iceI_getFromTableDatabaseById, paTableName, paId, paProperties, context);
    }

    /// \cond INTERNAL
    void _iceI_getFromTableDatabaseById(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ServerAppServer::GetFromTableDatabaseByIdResult>>&, const ::std::string&, const ::std::string&, const tyStringSequence&, const ::Ice::Context&);
    /// \endcond

    bool getAllTablesFromDatabase(tyStringSequence& paTables, ::std::string& paReturnMessage, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ServerAppServer::GetAllTablesFromDatabaseResult>(true, this, &ServerAppServerPrx::_iceI_getAllTablesFromDatabase, context).get();
        paTables = ::std::move(_result.paTables);
        paReturnMessage = ::std::move(_result.paReturnMessage);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getAllTablesFromDatabaseAsync(const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ServerAppServer::GetAllTablesFromDatabaseResult>>().get_future())
    {
        return _makePromiseOutgoing<ServerAppServer::GetAllTablesFromDatabaseResult, P>(false, this, &ServerAppServerPrx::_iceI_getAllTablesFromDatabase, context);
    }

    ::std::function<void()>
    getAllTablesFromDatabaseAsync(::std::function<void(bool, ::UVServerAppServer::tyStringSequence, ::std::string)> response,
                                  ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                  ::std::function<void(bool)> sent = nullptr,
                                  const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ServerAppServer::GetAllTablesFromDatabaseResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.paTables), ::std::move(_result.paReturnMessage));
        };
        return _makeLamdaOutgoing<ServerAppServer::GetAllTablesFromDatabaseResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &UVServerAppServer::ServerAppServerPrx::_iceI_getAllTablesFromDatabase, context);
    }

    /// \cond INTERNAL
    void _iceI_getAllTablesFromDatabase(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ServerAppServer::GetAllTablesFromDatabaseResult>>&, const ::Ice::Context&);
    /// \endcond

    bool getAllMethodsFromTable(const ::std::string& paTable, tyStringSequence& paMethodName, tyStringSequence& paAlias, tyStringSequence& paSource, tyStringSequence& paSourceName, tyStringSequence& paReturnType, ::std::string& paReturnMessage, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ServerAppServer::GetAllMethodsFromTableResult>(true, this, &ServerAppServerPrx::_iceI_getAllMethodsFromTable, paTable, context).get();
        paMethodName = ::std::move(_result.paMethodName);
        paAlias = ::std::move(_result.paAlias);
        paSource = ::std::move(_result.paSource);
        paSourceName = ::std::move(_result.paSourceName);
        paReturnType = ::std::move(_result.paReturnType);
        paReturnMessage = ::std::move(_result.paReturnMessage);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getAllMethodsFromTableAsync(const ::std::string& paTable, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ServerAppServer::GetAllMethodsFromTableResult>>().get_future())
    {
        return _makePromiseOutgoing<ServerAppServer::GetAllMethodsFromTableResult, P>(false, this, &ServerAppServerPrx::_iceI_getAllMethodsFromTable, paTable, context);
    }

    ::std::function<void()>
    getAllMethodsFromTableAsync(const ::std::string& paTable,
                                ::std::function<void(bool, ::UVServerAppServer::tyStringSequence, ::UVServerAppServer::tyStringSequence, ::UVServerAppServer::tyStringSequence, ::UVServerAppServer::tyStringSequence, ::UVServerAppServer::tyStringSequence, ::std::string)> response,
                                ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                ::std::function<void(bool)> sent = nullptr,
                                const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ServerAppServer::GetAllMethodsFromTableResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.paMethodName), ::std::move(_result.paAlias), ::std::move(_result.paSource), ::std::move(_result.paSourceName), ::std::move(_result.paReturnType), ::std::move(_result.paReturnMessage));
        };
        return _makeLamdaOutgoing<ServerAppServer::GetAllMethodsFromTableResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &UVServerAppServer::ServerAppServerPrx::_iceI_getAllMethodsFromTable, paTable, context);
    }

    /// \cond INTERNAL
    void _iceI_getAllMethodsFromTable(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ServerAppServer::GetAllMethodsFromTableResult>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    bool getAllPropertiesFromTable(const ::std::string& paTable, tyStringSequence& paPropertyName, tyStringSequence& paAlias, tyStringSequence& paType, tyStringSequence& paExtra, tyStringSequence& paReference, ::std::string& paReturnMessage, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ServerAppServer::GetAllPropertiesFromTableResult>(true, this, &ServerAppServerPrx::_iceI_getAllPropertiesFromTable, paTable, context).get();
        paPropertyName = ::std::move(_result.paPropertyName);
        paAlias = ::std::move(_result.paAlias);
        paType = ::std::move(_result.paType);
        paExtra = ::std::move(_result.paExtra);
        paReference = ::std::move(_result.paReference);
        paReturnMessage = ::std::move(_result.paReturnMessage);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto getAllPropertiesFromTableAsync(const ::std::string& paTable, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ServerAppServer::GetAllPropertiesFromTableResult>>().get_future())
    {
        return _makePromiseOutgoing<ServerAppServer::GetAllPropertiesFromTableResult, P>(false, this, &ServerAppServerPrx::_iceI_getAllPropertiesFromTable, paTable, context);
    }

    ::std::function<void()>
    getAllPropertiesFromTableAsync(const ::std::string& paTable,
                                   ::std::function<void(bool, ::UVServerAppServer::tyStringSequence, ::UVServerAppServer::tyStringSequence, ::UVServerAppServer::tyStringSequence, ::UVServerAppServer::tyStringSequence, ::UVServerAppServer::tyStringSequence, ::std::string)> response,
                                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                   ::std::function<void(bool)> sent = nullptr,
                                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ServerAppServer::GetAllPropertiesFromTableResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.paPropertyName), ::std::move(_result.paAlias), ::std::move(_result.paType), ::std::move(_result.paExtra), ::std::move(_result.paReference), ::std::move(_result.paReturnMessage));
        };
        return _makeLamdaOutgoing<ServerAppServer::GetAllPropertiesFromTableResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &UVServerAppServer::ServerAppServerPrx::_iceI_getAllPropertiesFromTable, paTable, context);
    }

    /// \cond INTERNAL
    void _iceI_getAllPropertiesFromTable(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ServerAppServer::GetAllPropertiesFromTableResult>>&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    bool giveWorkstationClientInfo(const ::std::string& paWorkstationName, const ::std::string& paPercentageMemUsage, const ::std::string& paPercentageDiskUsage, const ::std::string& paPercentageCpuUsage, ::std::string& paReturnMessage, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _result = _makePromiseOutgoing<ServerAppServer::GiveWorkstationClientInfoResult>(true, this, &ServerAppServerPrx::_iceI_giveWorkstationClientInfo, paWorkstationName, paPercentageMemUsage, paPercentageDiskUsage, paPercentageCpuUsage, context).get();
        paReturnMessage = ::std::move(_result.paReturnMessage);
        return _result.returnValue;
    }

    template<template<typename> class P = ::std::promise>
    auto giveWorkstationClientInfoAsync(const ::std::string& paWorkstationName, const ::std::string& paPercentageMemUsage, const ::std::string& paPercentageDiskUsage, const ::std::string& paPercentageCpuUsage, const ::Ice::Context& context = ::Ice::noExplicitContext)
        -> decltype(::std::declval<P<ServerAppServer::GiveWorkstationClientInfoResult>>().get_future())
    {
        return _makePromiseOutgoing<ServerAppServer::GiveWorkstationClientInfoResult, P>(false, this, &ServerAppServerPrx::_iceI_giveWorkstationClientInfo, paWorkstationName, paPercentageMemUsage, paPercentageDiskUsage, paPercentageCpuUsage, context);
    }

    ::std::function<void()>
    giveWorkstationClientInfoAsync(const ::std::string& paWorkstationName, const ::std::string& paPercentageMemUsage, const ::std::string& paPercentageDiskUsage, const ::std::string& paPercentageCpuUsage,
                                   ::std::function<void(bool, ::std::string)> response,
                                   ::std::function<void(::std::exception_ptr)> ex = nullptr,
                                   ::std::function<void(bool)> sent = nullptr,
                                   const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        auto _responseCb = [response](ServerAppServer::GiveWorkstationClientInfoResult&& _result)
        {
            response(_result.returnValue, ::std::move(_result.paReturnMessage));
        };
        return _makeLamdaOutgoing<ServerAppServer::GiveWorkstationClientInfoResult>(std::move(_responseCb), std::move(ex), std::move(sent), this, &UVServerAppServer::ServerAppServerPrx::_iceI_giveWorkstationClientInfo, paWorkstationName, paPercentageMemUsage, paPercentageDiskUsage, paPercentageCpuUsage, context);
    }

    /// \cond INTERNAL
    void _iceI_giveWorkstationClientInfo(const ::std::shared_ptr<::IceInternal::OutgoingAsyncT<ServerAppServer::GiveWorkstationClientInfoResult>>&, const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&);
    /// \endcond

    /**
     * Obtains the Slice type ID of this interface.
     * @return The fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:

    /// \cond INTERNAL
    ServerAppServerPrx() = default;
    friend ::std::shared_ptr<ServerAppServerPrx> IceInternal::createProxy<ServerAppServerPrx>();

    virtual ::std::shared_ptr<::Ice::ObjectPrx> _newInstance() const override;
    /// \endcond
};

}

/// \cond STREAM
namespace Ice
{

}
/// \endcond

/// \cond INTERNAL
namespace UVServerAppServer
{

using ServerAppServerPtr = ::std::shared_ptr<ServerAppServer>;
using ServerAppServerPrxPtr = ::std::shared_ptr<ServerAppServerPrx>;

}
/// \endcond

#else // C++98 mapping

namespace IceProxy
{

namespace UVServerAppServer
{

class ServerAppServer;
/// \cond INTERNAL
void _readProxy(::Ice::InputStream*, ::IceInternal::ProxyHandle< ServerAppServer>&);
::IceProxy::Ice::Object* upCast(ServerAppServer*);
/// \endcond

}

}

namespace UVServerAppServer
{

class ServerAppServer;
/// \cond INTERNAL
::Ice::Object* upCast(ServerAppServer*);
/// \endcond
typedef ::IceInternal::Handle< ServerAppServer> ServerAppServerPtr;
typedef ::IceInternal::ProxyHandle< ::IceProxy::UVServerAppServer::ServerAppServer> ServerAppServerPrx;
typedef ServerAppServerPrx ServerAppServerPrxPtr;
/// \cond INTERNAL
void _icePatchObjectPtr(ServerAppServerPtr&, const ::Ice::ObjectPtr&);
/// \endcond

}

namespace UVServerAppServer
{

typedef ::std::vector< ::std::string> tyStringSequence;

}

namespace UVServerAppServer
{

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_Ping.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_Ping.
 */
class Callback_ServerAppServer_Ping_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerAppServer_Ping_Base> Callback_ServerAppServer_PingPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_Shutdown.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_Shutdown.
 */
class Callback_ServerAppServer_Shutdown_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerAppServer_Shutdown_Base> Callback_ServerAppServer_ShutdownPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_insertIntoTableDatabase.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_insertIntoTableDatabase.
 */
class Callback_ServerAppServer_insertIntoTableDatabase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerAppServer_insertIntoTableDatabase_Base> Callback_ServerAppServer_insertIntoTableDatabasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_updateIntoTableDatabase.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_updateIntoTableDatabase.
 */
class Callback_ServerAppServer_updateIntoTableDatabase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerAppServer_updateIntoTableDatabase_Base> Callback_ServerAppServer_updateIntoTableDatabasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_deleteIntoTableDatabase.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_deleteIntoTableDatabase.
 */
class Callback_ServerAppServer_deleteIntoTableDatabase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerAppServer_deleteIntoTableDatabase_Base> Callback_ServerAppServer_deleteIntoTableDatabasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_getFromTableDatabaseGeneral.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_getFromTableDatabaseGeneral.
 */
class Callback_ServerAppServer_getFromTableDatabaseGeneral_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerAppServer_getFromTableDatabaseGeneral_Base> Callback_ServerAppServer_getFromTableDatabaseGeneralPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_getFromTableDatbaseByProperty.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_getFromTableDatbaseByProperty.
 */
class Callback_ServerAppServer_getFromTableDatbaseByProperty_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerAppServer_getFromTableDatbaseByProperty_Base> Callback_ServerAppServer_getFromTableDatbaseByPropertyPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_getFromTableDatabaseById.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_getFromTableDatabaseById.
 */
class Callback_ServerAppServer_getFromTableDatabaseById_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerAppServer_getFromTableDatabaseById_Base> Callback_ServerAppServer_getFromTableDatabaseByIdPtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_getAllTablesFromDatabase.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_getAllTablesFromDatabase.
 */
class Callback_ServerAppServer_getAllTablesFromDatabase_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerAppServer_getAllTablesFromDatabase_Base> Callback_ServerAppServer_getAllTablesFromDatabasePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_getAllMethodsFromTable.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_getAllMethodsFromTable.
 */
class Callback_ServerAppServer_getAllMethodsFromTable_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerAppServer_getAllMethodsFromTable_Base> Callback_ServerAppServer_getAllMethodsFromTablePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_getAllPropertiesFromTable.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_getAllPropertiesFromTable.
 */
class Callback_ServerAppServer_getAllPropertiesFromTable_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerAppServer_getAllPropertiesFromTable_Base> Callback_ServerAppServer_getAllPropertiesFromTablePtr;

/**
 * Base class for asynchronous callback wrapper classes used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_giveWorkstationClientInfo.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_giveWorkstationClientInfo.
 */
class Callback_ServerAppServer_giveWorkstationClientInfo_Base : public virtual ::IceInternal::CallbackBase { };
typedef ::IceUtil::Handle< Callback_ServerAppServer_giveWorkstationClientInfo_Base> Callback_ServerAppServer_giveWorkstationClientInfoPtr;

}

namespace IceProxy
{

namespace UVServerAppServer
{

class ServerAppServer : public virtual ::Ice::Proxy<ServerAppServer, ::IceProxy::Ice::Object>
{
public:

    bool Ping(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_Ping(_iceI_begin_Ping(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_Ping(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_Ping(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_Ping(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Ping(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_Ping(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Ping(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_Ping(const ::UVServerAppServer::Callback_ServerAppServer_PingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Ping(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_Ping(const ::Ice::Context& context, const ::UVServerAppServer::Callback_ServerAppServer_PingPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Ping(context, cb, cookie);
    }

    bool end_Ping(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_Ping(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    void Shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        end_Shutdown(_iceI_begin_Shutdown(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_Shutdown(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_Shutdown(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_Shutdown(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_Shutdown(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Shutdown(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_Shutdown(const ::UVServerAppServer::Callback_ServerAppServer_ShutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Shutdown(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_Shutdown(const ::Ice::Context& context, const ::UVServerAppServer::Callback_ServerAppServer_ShutdownPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_Shutdown(context, cb, cookie);
    }

    void end_Shutdown(const ::Ice::AsyncResultPtr& result);

private:

    ::Ice::AsyncResultPtr _iceI_begin_Shutdown(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool insertIntoTableDatabase(const ::std::string& paTableName, const ::UVServerAppServer::tyStringSequence& paColumns, const ::UVServerAppServer::tyStringSequence& paValue, const ::UVServerAppServer::tyStringSequence& paTypeValue, ::std::string& paReturnMessage, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_insertIntoTableDatabase(paReturnMessage, _iceI_begin_insertIntoTableDatabase(paTableName, paColumns, paValue, paTypeValue, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_insertIntoTableDatabase(const ::std::string& paTableName, const ::UVServerAppServer::tyStringSequence& paColumns, const ::UVServerAppServer::tyStringSequence& paValue, const ::UVServerAppServer::tyStringSequence& paTypeValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_insertIntoTableDatabase(paTableName, paColumns, paValue, paTypeValue, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_insertIntoTableDatabase(const ::std::string& paTableName, const ::UVServerAppServer::tyStringSequence& paColumns, const ::UVServerAppServer::tyStringSequence& paValue, const ::UVServerAppServer::tyStringSequence& paTypeValue, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_insertIntoTableDatabase(paTableName, paColumns, paValue, paTypeValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_insertIntoTableDatabase(const ::std::string& paTableName, const ::UVServerAppServer::tyStringSequence& paColumns, const ::UVServerAppServer::tyStringSequence& paValue, const ::UVServerAppServer::tyStringSequence& paTypeValue, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_insertIntoTableDatabase(paTableName, paColumns, paValue, paTypeValue, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_insertIntoTableDatabase(const ::std::string& paTableName, const ::UVServerAppServer::tyStringSequence& paColumns, const ::UVServerAppServer::tyStringSequence& paValue, const ::UVServerAppServer::tyStringSequence& paTypeValue, const ::UVServerAppServer::Callback_ServerAppServer_insertIntoTableDatabasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_insertIntoTableDatabase(paTableName, paColumns, paValue, paTypeValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_insertIntoTableDatabase(const ::std::string& paTableName, const ::UVServerAppServer::tyStringSequence& paColumns, const ::UVServerAppServer::tyStringSequence& paValue, const ::UVServerAppServer::tyStringSequence& paTypeValue, const ::Ice::Context& context, const ::UVServerAppServer::Callback_ServerAppServer_insertIntoTableDatabasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_insertIntoTableDatabase(paTableName, paColumns, paValue, paTypeValue, context, cb, cookie);
    }

    bool end_insertIntoTableDatabase(::std::string& paReturnMessage, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_insertIntoTableDatabase(::std::string& iceP_paReturnMessage, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_insertIntoTableDatabase(const ::std::string&, const ::UVServerAppServer::tyStringSequence&, const ::UVServerAppServer::tyStringSequence&, const ::UVServerAppServer::tyStringSequence&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool updateIntoTableDatabase(const ::std::string& paTableName, const ::std::string& paId, const ::UVServerAppServer::tyStringSequence& paColumns, const ::UVServerAppServer::tyStringSequence& paValue, const ::UVServerAppServer::tyStringSequence& paTypeValue, ::std::string& paReturnMessage, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_updateIntoTableDatabase(paReturnMessage, _iceI_begin_updateIntoTableDatabase(paTableName, paId, paColumns, paValue, paTypeValue, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_updateIntoTableDatabase(const ::std::string& paTableName, const ::std::string& paId, const ::UVServerAppServer::tyStringSequence& paColumns, const ::UVServerAppServer::tyStringSequence& paValue, const ::UVServerAppServer::tyStringSequence& paTypeValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_updateIntoTableDatabase(paTableName, paId, paColumns, paValue, paTypeValue, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_updateIntoTableDatabase(const ::std::string& paTableName, const ::std::string& paId, const ::UVServerAppServer::tyStringSequence& paColumns, const ::UVServerAppServer::tyStringSequence& paValue, const ::UVServerAppServer::tyStringSequence& paTypeValue, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateIntoTableDatabase(paTableName, paId, paColumns, paValue, paTypeValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateIntoTableDatabase(const ::std::string& paTableName, const ::std::string& paId, const ::UVServerAppServer::tyStringSequence& paColumns, const ::UVServerAppServer::tyStringSequence& paValue, const ::UVServerAppServer::tyStringSequence& paTypeValue, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateIntoTableDatabase(paTableName, paId, paColumns, paValue, paTypeValue, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateIntoTableDatabase(const ::std::string& paTableName, const ::std::string& paId, const ::UVServerAppServer::tyStringSequence& paColumns, const ::UVServerAppServer::tyStringSequence& paValue, const ::UVServerAppServer::tyStringSequence& paTypeValue, const ::UVServerAppServer::Callback_ServerAppServer_updateIntoTableDatabasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateIntoTableDatabase(paTableName, paId, paColumns, paValue, paTypeValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_updateIntoTableDatabase(const ::std::string& paTableName, const ::std::string& paId, const ::UVServerAppServer::tyStringSequence& paColumns, const ::UVServerAppServer::tyStringSequence& paValue, const ::UVServerAppServer::tyStringSequence& paTypeValue, const ::Ice::Context& context, const ::UVServerAppServer::Callback_ServerAppServer_updateIntoTableDatabasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_updateIntoTableDatabase(paTableName, paId, paColumns, paValue, paTypeValue, context, cb, cookie);
    }

    bool end_updateIntoTableDatabase(::std::string& paReturnMessage, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_updateIntoTableDatabase(::std::string& iceP_paReturnMessage, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_updateIntoTableDatabase(const ::std::string&, const ::std::string&, const ::UVServerAppServer::tyStringSequence&, const ::UVServerAppServer::tyStringSequence&, const ::UVServerAppServer::tyStringSequence&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool deleteIntoTableDatabase(const ::std::string& paTableName, const ::std::string& paId, ::std::string& paReturnMessage, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_deleteIntoTableDatabase(paReturnMessage, _iceI_begin_deleteIntoTableDatabase(paTableName, paId, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_deleteIntoTableDatabase(const ::std::string& paTableName, const ::std::string& paId, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_deleteIntoTableDatabase(paTableName, paId, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_deleteIntoTableDatabase(const ::std::string& paTableName, const ::std::string& paId, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_deleteIntoTableDatabase(paTableName, paId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_deleteIntoTableDatabase(const ::std::string& paTableName, const ::std::string& paId, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_deleteIntoTableDatabase(paTableName, paId, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_deleteIntoTableDatabase(const ::std::string& paTableName, const ::std::string& paId, const ::UVServerAppServer::Callback_ServerAppServer_deleteIntoTableDatabasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_deleteIntoTableDatabase(paTableName, paId, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_deleteIntoTableDatabase(const ::std::string& paTableName, const ::std::string& paId, const ::Ice::Context& context, const ::UVServerAppServer::Callback_ServerAppServer_deleteIntoTableDatabasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_deleteIntoTableDatabase(paTableName, paId, context, cb, cookie);
    }

    bool end_deleteIntoTableDatabase(::std::string& paReturnMessage, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_deleteIntoTableDatabase(::std::string& iceP_paReturnMessage, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_deleteIntoTableDatabase(const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool getFromTableDatabaseGeneral(const ::std::string& paTableName, const ::std::string& paStartValue, const ::std::string& paMaxValue, ::UVServerAppServer::tyStringSequence& paReturnId, ::UVServerAppServer::tyStringSequence& paReturnName, ::std::string& paMessage, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getFromTableDatabaseGeneral(paReturnId, paReturnName, paMessage, _iceI_begin_getFromTableDatabaseGeneral(paTableName, paStartValue, paMaxValue, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getFromTableDatabaseGeneral(const ::std::string& paTableName, const ::std::string& paStartValue, const ::std::string& paMaxValue, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getFromTableDatabaseGeneral(paTableName, paStartValue, paMaxValue, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFromTableDatabaseGeneral(const ::std::string& paTableName, const ::std::string& paStartValue, const ::std::string& paMaxValue, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getFromTableDatabaseGeneral(paTableName, paStartValue, paMaxValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getFromTableDatabaseGeneral(const ::std::string& paTableName, const ::std::string& paStartValue, const ::std::string& paMaxValue, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getFromTableDatabaseGeneral(paTableName, paStartValue, paMaxValue, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getFromTableDatabaseGeneral(const ::std::string& paTableName, const ::std::string& paStartValue, const ::std::string& paMaxValue, const ::UVServerAppServer::Callback_ServerAppServer_getFromTableDatabaseGeneralPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getFromTableDatabaseGeneral(paTableName, paStartValue, paMaxValue, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getFromTableDatabaseGeneral(const ::std::string& paTableName, const ::std::string& paStartValue, const ::std::string& paMaxValue, const ::Ice::Context& context, const ::UVServerAppServer::Callback_ServerAppServer_getFromTableDatabaseGeneralPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getFromTableDatabaseGeneral(paTableName, paStartValue, paMaxValue, context, cb, cookie);
    }

    bool end_getFromTableDatabaseGeneral(::UVServerAppServer::tyStringSequence& paReturnId, ::UVServerAppServer::tyStringSequence& paReturnName, ::std::string& paMessage, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getFromTableDatabaseGeneral(::UVServerAppServer::tyStringSequence& iceP_paReturnId, ::UVServerAppServer::tyStringSequence& iceP_paReturnName, ::std::string& iceP_paMessage, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getFromTableDatabaseGeneral(const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool getFromTableDatbaseByProperty(const ::std::string& paTableName, const ::std::string& paStartValue, const ::std::string& paMaxValue, const ::UVServerAppServer::tyStringSequence& paProperties, const ::UVServerAppServer::tyStringSequence& paValue, const ::UVServerAppServer::tyStringSequence& paTypeValue, const ::UVServerAppServer::tyStringSequence& paLogExp, ::UVServerAppServer::tyStringSequence& paReturnId, ::std::string& paReturnMessage, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getFromTableDatbaseByProperty(paReturnId, paReturnMessage, _iceI_begin_getFromTableDatbaseByProperty(paTableName, paStartValue, paMaxValue, paProperties, paValue, paTypeValue, paLogExp, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getFromTableDatbaseByProperty(const ::std::string& paTableName, const ::std::string& paStartValue, const ::std::string& paMaxValue, const ::UVServerAppServer::tyStringSequence& paProperties, const ::UVServerAppServer::tyStringSequence& paValue, const ::UVServerAppServer::tyStringSequence& paTypeValue, const ::UVServerAppServer::tyStringSequence& paLogExp, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getFromTableDatbaseByProperty(paTableName, paStartValue, paMaxValue, paProperties, paValue, paTypeValue, paLogExp, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFromTableDatbaseByProperty(const ::std::string& paTableName, const ::std::string& paStartValue, const ::std::string& paMaxValue, const ::UVServerAppServer::tyStringSequence& paProperties, const ::UVServerAppServer::tyStringSequence& paValue, const ::UVServerAppServer::tyStringSequence& paTypeValue, const ::UVServerAppServer::tyStringSequence& paLogExp, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getFromTableDatbaseByProperty(paTableName, paStartValue, paMaxValue, paProperties, paValue, paTypeValue, paLogExp, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getFromTableDatbaseByProperty(const ::std::string& paTableName, const ::std::string& paStartValue, const ::std::string& paMaxValue, const ::UVServerAppServer::tyStringSequence& paProperties, const ::UVServerAppServer::tyStringSequence& paValue, const ::UVServerAppServer::tyStringSequence& paTypeValue, const ::UVServerAppServer::tyStringSequence& paLogExp, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getFromTableDatbaseByProperty(paTableName, paStartValue, paMaxValue, paProperties, paValue, paTypeValue, paLogExp, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getFromTableDatbaseByProperty(const ::std::string& paTableName, const ::std::string& paStartValue, const ::std::string& paMaxValue, const ::UVServerAppServer::tyStringSequence& paProperties, const ::UVServerAppServer::tyStringSequence& paValue, const ::UVServerAppServer::tyStringSequence& paTypeValue, const ::UVServerAppServer::tyStringSequence& paLogExp, const ::UVServerAppServer::Callback_ServerAppServer_getFromTableDatbaseByPropertyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getFromTableDatbaseByProperty(paTableName, paStartValue, paMaxValue, paProperties, paValue, paTypeValue, paLogExp, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getFromTableDatbaseByProperty(const ::std::string& paTableName, const ::std::string& paStartValue, const ::std::string& paMaxValue, const ::UVServerAppServer::tyStringSequence& paProperties, const ::UVServerAppServer::tyStringSequence& paValue, const ::UVServerAppServer::tyStringSequence& paTypeValue, const ::UVServerAppServer::tyStringSequence& paLogExp, const ::Ice::Context& context, const ::UVServerAppServer::Callback_ServerAppServer_getFromTableDatbaseByPropertyPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getFromTableDatbaseByProperty(paTableName, paStartValue, paMaxValue, paProperties, paValue, paTypeValue, paLogExp, context, cb, cookie);
    }

    bool end_getFromTableDatbaseByProperty(::UVServerAppServer::tyStringSequence& paReturnId, ::std::string& paReturnMessage, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getFromTableDatbaseByProperty(::UVServerAppServer::tyStringSequence& iceP_paReturnId, ::std::string& iceP_paReturnMessage, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getFromTableDatbaseByProperty(const ::std::string&, const ::std::string&, const ::std::string&, const ::UVServerAppServer::tyStringSequence&, const ::UVServerAppServer::tyStringSequence&, const ::UVServerAppServer::tyStringSequence&, const ::UVServerAppServer::tyStringSequence&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool getFromTableDatabaseById(const ::std::string& paTableName, const ::std::string& paId, const ::UVServerAppServer::tyStringSequence& paProperties, ::UVServerAppServer::tyStringSequence& paReturnValue, ::std::string& paReturnMessage, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getFromTableDatabaseById(paReturnValue, paReturnMessage, _iceI_begin_getFromTableDatabaseById(paTableName, paId, paProperties, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getFromTableDatabaseById(const ::std::string& paTableName, const ::std::string& paId, const ::UVServerAppServer::tyStringSequence& paProperties, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getFromTableDatabaseById(paTableName, paId, paProperties, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getFromTableDatabaseById(const ::std::string& paTableName, const ::std::string& paId, const ::UVServerAppServer::tyStringSequence& paProperties, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getFromTableDatabaseById(paTableName, paId, paProperties, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getFromTableDatabaseById(const ::std::string& paTableName, const ::std::string& paId, const ::UVServerAppServer::tyStringSequence& paProperties, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getFromTableDatabaseById(paTableName, paId, paProperties, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getFromTableDatabaseById(const ::std::string& paTableName, const ::std::string& paId, const ::UVServerAppServer::tyStringSequence& paProperties, const ::UVServerAppServer::Callback_ServerAppServer_getFromTableDatabaseByIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getFromTableDatabaseById(paTableName, paId, paProperties, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getFromTableDatabaseById(const ::std::string& paTableName, const ::std::string& paId, const ::UVServerAppServer::tyStringSequence& paProperties, const ::Ice::Context& context, const ::UVServerAppServer::Callback_ServerAppServer_getFromTableDatabaseByIdPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getFromTableDatabaseById(paTableName, paId, paProperties, context, cb, cookie);
    }

    bool end_getFromTableDatabaseById(::UVServerAppServer::tyStringSequence& paReturnValue, ::std::string& paReturnMessage, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getFromTableDatabaseById(::UVServerAppServer::tyStringSequence& iceP_paReturnValue, ::std::string& iceP_paReturnMessage, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getFromTableDatabaseById(const ::std::string&, const ::std::string&, const ::UVServerAppServer::tyStringSequence&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool getAllTablesFromDatabase(::UVServerAppServer::tyStringSequence& paTables, ::std::string& paReturnMessage, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getAllTablesFromDatabase(paTables, paReturnMessage, _iceI_begin_getAllTablesFromDatabase(context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getAllTablesFromDatabase(const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getAllTablesFromDatabase(context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAllTablesFromDatabase(const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAllTablesFromDatabase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllTablesFromDatabase(const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAllTablesFromDatabase(context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllTablesFromDatabase(const ::UVServerAppServer::Callback_ServerAppServer_getAllTablesFromDatabasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAllTablesFromDatabase(::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllTablesFromDatabase(const ::Ice::Context& context, const ::UVServerAppServer::Callback_ServerAppServer_getAllTablesFromDatabasePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAllTablesFromDatabase(context, cb, cookie);
    }

    bool end_getAllTablesFromDatabase(::UVServerAppServer::tyStringSequence& paTables, ::std::string& paReturnMessage, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getAllTablesFromDatabase(::UVServerAppServer::tyStringSequence& iceP_paTables, ::std::string& iceP_paReturnMessage, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getAllTablesFromDatabase(const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool getAllMethodsFromTable(const ::std::string& paTable, ::UVServerAppServer::tyStringSequence& paMethodName, ::UVServerAppServer::tyStringSequence& paAlias, ::UVServerAppServer::tyStringSequence& paSource, ::UVServerAppServer::tyStringSequence& paSourceName, ::UVServerAppServer::tyStringSequence& paReturnType, ::std::string& paReturnMessage, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getAllMethodsFromTable(paMethodName, paAlias, paSource, paSourceName, paReturnType, paReturnMessage, _iceI_begin_getAllMethodsFromTable(paTable, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getAllMethodsFromTable(const ::std::string& paTable, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getAllMethodsFromTable(paTable, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAllMethodsFromTable(const ::std::string& paTable, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAllMethodsFromTable(paTable, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllMethodsFromTable(const ::std::string& paTable, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAllMethodsFromTable(paTable, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllMethodsFromTable(const ::std::string& paTable, const ::UVServerAppServer::Callback_ServerAppServer_getAllMethodsFromTablePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAllMethodsFromTable(paTable, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllMethodsFromTable(const ::std::string& paTable, const ::Ice::Context& context, const ::UVServerAppServer::Callback_ServerAppServer_getAllMethodsFromTablePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAllMethodsFromTable(paTable, context, cb, cookie);
    }

    bool end_getAllMethodsFromTable(::UVServerAppServer::tyStringSequence& paMethodName, ::UVServerAppServer::tyStringSequence& paAlias, ::UVServerAppServer::tyStringSequence& paSource, ::UVServerAppServer::tyStringSequence& paSourceName, ::UVServerAppServer::tyStringSequence& paReturnType, ::std::string& paReturnMessage, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getAllMethodsFromTable(::UVServerAppServer::tyStringSequence& iceP_paMethodName, ::UVServerAppServer::tyStringSequence& iceP_paAlias, ::UVServerAppServer::tyStringSequence& iceP_paSource, ::UVServerAppServer::tyStringSequence& iceP_paSourceName, ::UVServerAppServer::tyStringSequence& iceP_paReturnType, ::std::string& iceP_paReturnMessage, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getAllMethodsFromTable(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool getAllPropertiesFromTable(const ::std::string& paTable, ::UVServerAppServer::tyStringSequence& paPropertyName, ::UVServerAppServer::tyStringSequence& paAlias, ::UVServerAppServer::tyStringSequence& paType, ::UVServerAppServer::tyStringSequence& paExtra, ::UVServerAppServer::tyStringSequence& paReference, ::std::string& paReturnMessage, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_getAllPropertiesFromTable(paPropertyName, paAlias, paType, paExtra, paReference, paReturnMessage, _iceI_begin_getAllPropertiesFromTable(paTable, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_getAllPropertiesFromTable(const ::std::string& paTable, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_getAllPropertiesFromTable(paTable, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_getAllPropertiesFromTable(const ::std::string& paTable, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAllPropertiesFromTable(paTable, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllPropertiesFromTable(const ::std::string& paTable, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAllPropertiesFromTable(paTable, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllPropertiesFromTable(const ::std::string& paTable, const ::UVServerAppServer::Callback_ServerAppServer_getAllPropertiesFromTablePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAllPropertiesFromTable(paTable, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_getAllPropertiesFromTable(const ::std::string& paTable, const ::Ice::Context& context, const ::UVServerAppServer::Callback_ServerAppServer_getAllPropertiesFromTablePtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_getAllPropertiesFromTable(paTable, context, cb, cookie);
    }

    bool end_getAllPropertiesFromTable(::UVServerAppServer::tyStringSequence& paPropertyName, ::UVServerAppServer::tyStringSequence& paAlias, ::UVServerAppServer::tyStringSequence& paType, ::UVServerAppServer::tyStringSequence& paExtra, ::UVServerAppServer::tyStringSequence& paReference, ::std::string& paReturnMessage, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_getAllPropertiesFromTable(::UVServerAppServer::tyStringSequence& iceP_paPropertyName, ::UVServerAppServer::tyStringSequence& iceP_paAlias, ::UVServerAppServer::tyStringSequence& iceP_paType, ::UVServerAppServer::tyStringSequence& iceP_paExtra, ::UVServerAppServer::tyStringSequence& iceP_paReference, ::std::string& iceP_paReturnMessage, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_getAllPropertiesFromTable(const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    bool giveWorkstationClientInfo(const ::std::string& paWorkstationName, const ::std::string& paPercentageMemUsage, const ::std::string& paPercentageDiskUsage, const ::std::string& paPercentageCpuUsage, ::std::string& paReturnMessage, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return end_giveWorkstationClientInfo(paReturnMessage, _iceI_begin_giveWorkstationClientInfo(paWorkstationName, paPercentageMemUsage, paPercentageDiskUsage, paPercentageCpuUsage, context, ::IceInternal::dummyCallback, 0, true));
    }

    ::Ice::AsyncResultPtr begin_giveWorkstationClientInfo(const ::std::string& paWorkstationName, const ::std::string& paPercentageMemUsage, const ::std::string& paPercentageDiskUsage, const ::std::string& paPercentageCpuUsage, const ::Ice::Context& context = ::Ice::noExplicitContext)
    {
        return _iceI_begin_giveWorkstationClientInfo(paWorkstationName, paPercentageMemUsage, paPercentageDiskUsage, paPercentageCpuUsage, context, ::IceInternal::dummyCallback, 0);
    }

    ::Ice::AsyncResultPtr begin_giveWorkstationClientInfo(const ::std::string& paWorkstationName, const ::std::string& paPercentageMemUsage, const ::std::string& paPercentageDiskUsage, const ::std::string& paPercentageCpuUsage, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_giveWorkstationClientInfo(paWorkstationName, paPercentageMemUsage, paPercentageDiskUsage, paPercentageCpuUsage, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_giveWorkstationClientInfo(const ::std::string& paWorkstationName, const ::std::string& paPercentageMemUsage, const ::std::string& paPercentageDiskUsage, const ::std::string& paPercentageCpuUsage, const ::Ice::Context& context, const ::Ice::CallbackPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_giveWorkstationClientInfo(paWorkstationName, paPercentageMemUsage, paPercentageDiskUsage, paPercentageCpuUsage, context, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_giveWorkstationClientInfo(const ::std::string& paWorkstationName, const ::std::string& paPercentageMemUsage, const ::std::string& paPercentageDiskUsage, const ::std::string& paPercentageCpuUsage, const ::UVServerAppServer::Callback_ServerAppServer_giveWorkstationClientInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_giveWorkstationClientInfo(paWorkstationName, paPercentageMemUsage, paPercentageDiskUsage, paPercentageCpuUsage, ::Ice::noExplicitContext, cb, cookie);
    }

    ::Ice::AsyncResultPtr begin_giveWorkstationClientInfo(const ::std::string& paWorkstationName, const ::std::string& paPercentageMemUsage, const ::std::string& paPercentageDiskUsage, const ::std::string& paPercentageCpuUsage, const ::Ice::Context& context, const ::UVServerAppServer::Callback_ServerAppServer_giveWorkstationClientInfoPtr& cb, const ::Ice::LocalObjectPtr& cookie = 0)
    {
        return _iceI_begin_giveWorkstationClientInfo(paWorkstationName, paPercentageMemUsage, paPercentageDiskUsage, paPercentageCpuUsage, context, cb, cookie);
    }

    bool end_giveWorkstationClientInfo(::std::string& paReturnMessage, const ::Ice::AsyncResultPtr& result);
    /// \cond INTERNAL

    void _iceI_end_giveWorkstationClientInfo(::std::string& iceP_paReturnMessage, bool& ret, const ::Ice::AsyncResultPtr&);
    /// \endcond

private:

    ::Ice::AsyncResultPtr _iceI_begin_giveWorkstationClientInfo(const ::std::string&, const ::std::string&, const ::std::string&, const ::std::string&, const ::Ice::Context&, const ::IceInternal::CallbackBasePtr&, const ::Ice::LocalObjectPtr& cookie = 0, bool sync = false);

public:

    /**
     * Obtains the Slice type ID corresponding to this interface.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

protected:
    /// \cond INTERNAL

    virtual ::IceProxy::Ice::Object* _newInstance() const;
    /// \endcond
};

}

}

namespace UVServerAppServer
{

class ServerAppServer : public virtual ::Ice::Object
{
public:

    typedef ServerAppServerPrx ProxyType;
    typedef ServerAppServerPtr PointerType;

    virtual ~ServerAppServer();

#ifdef ICE_CPP11_COMPILER
    ServerAppServer() = default;
    ServerAppServer(const ServerAppServer&) = default;
    ServerAppServer& operator=(const ServerAppServer&) = default;
#endif

    /**
     * Determines whether this object supports an interface with the given Slice type ID.
     * @param id The fully-scoped Slice type ID.
     * @param current The Current object for the invocation.
     * @return True if this object supports the interface, false, otherwise.
     */
    virtual bool ice_isA(const ::std::string& id, const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a list of the Slice type IDs representing the interfaces supported by this object.
     * @param current The Current object for the invocation.
     * @return A list of fully-scoped type IDs.
     */
    virtual ::std::vector< ::std::string> ice_ids(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains a Slice type ID representing the most-derived interface supported by this object.
     * @param current The Current object for the invocation.
     * @return A fully-scoped type ID.
     */
    virtual const ::std::string& ice_id(const ::Ice::Current& current = ::Ice::emptyCurrent) const;

    /**
     * Obtains the Slice type ID corresponding to this class.
     * @return A fully-scoped type ID.
     */
    static const ::std::string& ice_staticId();

    virtual bool Ping(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_Ping(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual void Shutdown(const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_Shutdown(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool insertIntoTableDatabase(const ::std::string& paTableName, const tyStringSequence& paColumns, const tyStringSequence& paValue, const tyStringSequence& paTypeValue, ::std::string& paReturnMessage, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_insertIntoTableDatabase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool updateIntoTableDatabase(const ::std::string& paTableName, const ::std::string& paId, const tyStringSequence& paColumns, const tyStringSequence& paValue, const tyStringSequence& paTypeValue, ::std::string& paReturnMessage, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_updateIntoTableDatabase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool deleteIntoTableDatabase(const ::std::string& paTableName, const ::std::string& paId, ::std::string& paReturnMessage, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_deleteIntoTableDatabase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool getFromTableDatabaseGeneral(const ::std::string& paTableName, const ::std::string& paStartValue, const ::std::string& paMaxValue, tyStringSequence& paReturnId, tyStringSequence& paReturnName, ::std::string& paMessage, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getFromTableDatabaseGeneral(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool getFromTableDatbaseByProperty(const ::std::string& paTableName, const ::std::string& paStartValue, const ::std::string& paMaxValue, const tyStringSequence& paProperties, const tyStringSequence& paValue, const tyStringSequence& paTypeValue, const tyStringSequence& paLogExp, tyStringSequence& paReturnId, ::std::string& paReturnMessage, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getFromTableDatbaseByProperty(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool getFromTableDatabaseById(const ::std::string& paTableName, const ::std::string& paId, const tyStringSequence& paProperties, tyStringSequence& paReturnValue, ::std::string& paReturnMessage, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getFromTableDatabaseById(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool getAllTablesFromDatabase(tyStringSequence& paTables, ::std::string& paReturnMessage, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getAllTablesFromDatabase(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool getAllMethodsFromTable(const ::std::string& paTable, tyStringSequence& paMethodName, tyStringSequence& paAlias, tyStringSequence& paSource, tyStringSequence& paSourceName, tyStringSequence& paReturnType, ::std::string& paReturnMessage, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getAllMethodsFromTable(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool getAllPropertiesFromTable(const ::std::string& paTable, tyStringSequence& paPropertyName, tyStringSequence& paAlias, tyStringSequence& paType, tyStringSequence& paExtra, tyStringSequence& paReference, ::std::string& paReturnMessage, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_getAllPropertiesFromTable(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    virtual bool giveWorkstationClientInfo(const ::std::string& paWorkstationName, const ::std::string& paPercentageMemUsage, const ::std::string& paPercentageDiskUsage, const ::std::string& paPercentageCpuUsage, ::std::string& paReturnMessage, const ::Ice::Current& current = ::Ice::emptyCurrent) = 0;
    /// \cond INTERNAL
    bool _iceD_giveWorkstationClientInfo(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

    /// \cond INTERNAL
    virtual bool _iceDispatch(::IceInternal::Incoming&, const ::Ice::Current&);
    /// \endcond

protected:

    /// \cond STREAM
    virtual void _iceWriteImpl(::Ice::OutputStream*) const;
    virtual void _iceReadImpl(::Ice::InputStream*);
    /// \endcond
};

/// \cond INTERNAL
inline bool operator==(const ServerAppServer& lhs, const ServerAppServer& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) == static_cast<const ::Ice::Object&>(rhs);
}

inline bool operator<(const ServerAppServer& lhs, const ServerAppServer& rhs)
{
    return static_cast<const ::Ice::Object&>(lhs) < static_cast<const ::Ice::Object&>(rhs);
}
/// \endcond

}

/// \cond STREAM
namespace Ice
{

}
/// \endcond

namespace UVServerAppServer
{

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_Ping.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_Ping.
 */
template<class T>
class CallbackNC_ServerAppServer_Ping : public Callback_ServerAppServer_Ping_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool);

    CallbackNC_ServerAppServer_Ping(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_Ping(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_Ping.
 */
template<class T> Callback_ServerAppServer_PingPtr
newCallback_ServerAppServer_Ping(const IceUtil::Handle<T>& instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_Ping<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_Ping.
 */
template<class T> Callback_ServerAppServer_PingPtr
newCallback_ServerAppServer_Ping(T* instance, void (T::*cb)(bool), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_Ping<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_Ping.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_Ping.
 */
template<class T, typename CT>
class Callback_ServerAppServer_Ping : public Callback_ServerAppServer_Ping_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const CT&);

    Callback_ServerAppServer_Ping(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        bool ret;
        try
        {
            ret = proxy->end_Ping(result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_Ping.
 */
template<class T, typename CT> Callback_ServerAppServer_PingPtr
newCallback_ServerAppServer_Ping(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_Ping<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_Ping.
 */
template<class T, typename CT> Callback_ServerAppServer_PingPtr
newCallback_ServerAppServer_Ping(T* instance, void (T::*cb)(bool, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_Ping<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_Shutdown.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_Shutdown.
 */
template<class T>
class CallbackNC_ServerAppServer_Shutdown : public Callback_ServerAppServer_Shutdown_Base, public ::IceInternal::OnewayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)();

    CallbackNC_ServerAppServer_Shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallbackNC<T>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_Shutdown.
 */
template<class T> Callback_ServerAppServer_ShutdownPtr
newCallback_ServerAppServer_Shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_Shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_Shutdown.
 */
template<class T> Callback_ServerAppServer_ShutdownPtr
newCallback_ServerAppServer_Shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_Shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_Shutdown.
 */
template<class T> Callback_ServerAppServer_ShutdownPtr
newCallback_ServerAppServer_Shutdown(T* instance, void (T::*cb)(), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_Shutdown<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_Shutdown.
 */
template<class T> Callback_ServerAppServer_ShutdownPtr
newCallback_ServerAppServer_Shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_Shutdown<T>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_Shutdown.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_Shutdown.
 */
template<class T, typename CT>
class Callback_ServerAppServer_Shutdown : public Callback_ServerAppServer_Shutdown_Base, public ::IceInternal::OnewayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(const CT&);

    Callback_ServerAppServer_Shutdown(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::OnewayCallback<T, CT>(obj, cb, excb, sentcb)
    {
    }
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_Shutdown.
 */
template<class T, typename CT> Callback_ServerAppServer_ShutdownPtr
newCallback_ServerAppServer_Shutdown(const IceUtil::Handle<T>& instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_Shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_Shutdown.
 */
template<class T, typename CT> Callback_ServerAppServer_ShutdownPtr
newCallback_ServerAppServer_Shutdown(const IceUtil::Handle<T>& instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_Shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_Shutdown.
 */
template<class T, typename CT> Callback_ServerAppServer_ShutdownPtr
newCallback_ServerAppServer_Shutdown(T* instance, void (T::*cb)(const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_Shutdown<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_Shutdown.
 */
template<class T, typename CT> Callback_ServerAppServer_ShutdownPtr
newCallback_ServerAppServer_Shutdown(T* instance, void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_Shutdown<T, CT>(instance, 0, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_insertIntoTableDatabase.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_insertIntoTableDatabase.
 */
template<class T>
class CallbackNC_ServerAppServer_insertIntoTableDatabase : public Callback_ServerAppServer_insertIntoTableDatabase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const ::std::string&);

    CallbackNC_ServerAppServer_insertIntoTableDatabase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_paReturnMessage;
        bool ret;
        try
        {
            ret = proxy->end_insertIntoTableDatabase(iceP_paReturnMessage, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_paReturnMessage);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_insertIntoTableDatabase.
 */
template<class T> Callback_ServerAppServer_insertIntoTableDatabasePtr
newCallback_ServerAppServer_insertIntoTableDatabase(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_insertIntoTableDatabase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_insertIntoTableDatabase.
 */
template<class T> Callback_ServerAppServer_insertIntoTableDatabasePtr
newCallback_ServerAppServer_insertIntoTableDatabase(T* instance, void (T::*cb)(bool, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_insertIntoTableDatabase<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_insertIntoTableDatabase.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_insertIntoTableDatabase.
 */
template<class T, typename CT>
class Callback_ServerAppServer_insertIntoTableDatabase : public Callback_ServerAppServer_insertIntoTableDatabase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const ::std::string&, const CT&);

    Callback_ServerAppServer_insertIntoTableDatabase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_paReturnMessage;
        bool ret;
        try
        {
            ret = proxy->end_insertIntoTableDatabase(iceP_paReturnMessage, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_paReturnMessage, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_insertIntoTableDatabase.
 */
template<class T, typename CT> Callback_ServerAppServer_insertIntoTableDatabasePtr
newCallback_ServerAppServer_insertIntoTableDatabase(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_insertIntoTableDatabase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_insertIntoTableDatabase.
 */
template<class T, typename CT> Callback_ServerAppServer_insertIntoTableDatabasePtr
newCallback_ServerAppServer_insertIntoTableDatabase(T* instance, void (T::*cb)(bool, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_insertIntoTableDatabase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_updateIntoTableDatabase.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_updateIntoTableDatabase.
 */
template<class T>
class CallbackNC_ServerAppServer_updateIntoTableDatabase : public Callback_ServerAppServer_updateIntoTableDatabase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const ::std::string&);

    CallbackNC_ServerAppServer_updateIntoTableDatabase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_paReturnMessage;
        bool ret;
        try
        {
            ret = proxy->end_updateIntoTableDatabase(iceP_paReturnMessage, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_paReturnMessage);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_updateIntoTableDatabase.
 */
template<class T> Callback_ServerAppServer_updateIntoTableDatabasePtr
newCallback_ServerAppServer_updateIntoTableDatabase(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_updateIntoTableDatabase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_updateIntoTableDatabase.
 */
template<class T> Callback_ServerAppServer_updateIntoTableDatabasePtr
newCallback_ServerAppServer_updateIntoTableDatabase(T* instance, void (T::*cb)(bool, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_updateIntoTableDatabase<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_updateIntoTableDatabase.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_updateIntoTableDatabase.
 */
template<class T, typename CT>
class Callback_ServerAppServer_updateIntoTableDatabase : public Callback_ServerAppServer_updateIntoTableDatabase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const ::std::string&, const CT&);

    Callback_ServerAppServer_updateIntoTableDatabase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_paReturnMessage;
        bool ret;
        try
        {
            ret = proxy->end_updateIntoTableDatabase(iceP_paReturnMessage, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_paReturnMessage, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_updateIntoTableDatabase.
 */
template<class T, typename CT> Callback_ServerAppServer_updateIntoTableDatabasePtr
newCallback_ServerAppServer_updateIntoTableDatabase(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_updateIntoTableDatabase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_updateIntoTableDatabase.
 */
template<class T, typename CT> Callback_ServerAppServer_updateIntoTableDatabasePtr
newCallback_ServerAppServer_updateIntoTableDatabase(T* instance, void (T::*cb)(bool, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_updateIntoTableDatabase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_deleteIntoTableDatabase.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_deleteIntoTableDatabase.
 */
template<class T>
class CallbackNC_ServerAppServer_deleteIntoTableDatabase : public Callback_ServerAppServer_deleteIntoTableDatabase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const ::std::string&);

    CallbackNC_ServerAppServer_deleteIntoTableDatabase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_paReturnMessage;
        bool ret;
        try
        {
            ret = proxy->end_deleteIntoTableDatabase(iceP_paReturnMessage, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_paReturnMessage);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_deleteIntoTableDatabase.
 */
template<class T> Callback_ServerAppServer_deleteIntoTableDatabasePtr
newCallback_ServerAppServer_deleteIntoTableDatabase(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_deleteIntoTableDatabase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_deleteIntoTableDatabase.
 */
template<class T> Callback_ServerAppServer_deleteIntoTableDatabasePtr
newCallback_ServerAppServer_deleteIntoTableDatabase(T* instance, void (T::*cb)(bool, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_deleteIntoTableDatabase<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_deleteIntoTableDatabase.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_deleteIntoTableDatabase.
 */
template<class T, typename CT>
class Callback_ServerAppServer_deleteIntoTableDatabase : public Callback_ServerAppServer_deleteIntoTableDatabase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const ::std::string&, const CT&);

    Callback_ServerAppServer_deleteIntoTableDatabase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_paReturnMessage;
        bool ret;
        try
        {
            ret = proxy->end_deleteIntoTableDatabase(iceP_paReturnMessage, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_paReturnMessage, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_deleteIntoTableDatabase.
 */
template<class T, typename CT> Callback_ServerAppServer_deleteIntoTableDatabasePtr
newCallback_ServerAppServer_deleteIntoTableDatabase(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_deleteIntoTableDatabase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_deleteIntoTableDatabase.
 */
template<class T, typename CT> Callback_ServerAppServer_deleteIntoTableDatabasePtr
newCallback_ServerAppServer_deleteIntoTableDatabase(T* instance, void (T::*cb)(bool, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_deleteIntoTableDatabase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_getFromTableDatabaseGeneral.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_getFromTableDatabaseGeneral.
 */
template<class T>
class CallbackNC_ServerAppServer_getFromTableDatabaseGeneral : public Callback_ServerAppServer_getFromTableDatabaseGeneral_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const tyStringSequence&, const tyStringSequence&, const ::std::string&);

    CallbackNC_ServerAppServer_getFromTableDatabaseGeneral(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        tyStringSequence iceP_paReturnId;
        tyStringSequence iceP_paReturnName;
        ::std::string iceP_paMessage;
        bool ret;
        try
        {
            ret = proxy->end_getFromTableDatabaseGeneral(iceP_paReturnId, iceP_paReturnName, iceP_paMessage, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_paReturnId, iceP_paReturnName, iceP_paMessage);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getFromTableDatabaseGeneral.
 */
template<class T> Callback_ServerAppServer_getFromTableDatabaseGeneralPtr
newCallback_ServerAppServer_getFromTableDatabaseGeneral(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const tyStringSequence&, const tyStringSequence&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_getFromTableDatabaseGeneral<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getFromTableDatabaseGeneral.
 */
template<class T> Callback_ServerAppServer_getFromTableDatabaseGeneralPtr
newCallback_ServerAppServer_getFromTableDatabaseGeneral(T* instance, void (T::*cb)(bool, const tyStringSequence&, const tyStringSequence&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_getFromTableDatabaseGeneral<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_getFromTableDatabaseGeneral.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_getFromTableDatabaseGeneral.
 */
template<class T, typename CT>
class Callback_ServerAppServer_getFromTableDatabaseGeneral : public Callback_ServerAppServer_getFromTableDatabaseGeneral_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const tyStringSequence&, const tyStringSequence&, const ::std::string&, const CT&);

    Callback_ServerAppServer_getFromTableDatabaseGeneral(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        tyStringSequence iceP_paReturnId;
        tyStringSequence iceP_paReturnName;
        ::std::string iceP_paMessage;
        bool ret;
        try
        {
            ret = proxy->end_getFromTableDatabaseGeneral(iceP_paReturnId, iceP_paReturnName, iceP_paMessage, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_paReturnId, iceP_paReturnName, iceP_paMessage, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getFromTableDatabaseGeneral.
 */
template<class T, typename CT> Callback_ServerAppServer_getFromTableDatabaseGeneralPtr
newCallback_ServerAppServer_getFromTableDatabaseGeneral(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const tyStringSequence&, const tyStringSequence&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_getFromTableDatabaseGeneral<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getFromTableDatabaseGeneral.
 */
template<class T, typename CT> Callback_ServerAppServer_getFromTableDatabaseGeneralPtr
newCallback_ServerAppServer_getFromTableDatabaseGeneral(T* instance, void (T::*cb)(bool, const tyStringSequence&, const tyStringSequence&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_getFromTableDatabaseGeneral<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_getFromTableDatbaseByProperty.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_getFromTableDatbaseByProperty.
 */
template<class T>
class CallbackNC_ServerAppServer_getFromTableDatbaseByProperty : public Callback_ServerAppServer_getFromTableDatbaseByProperty_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const tyStringSequence&, const ::std::string&);

    CallbackNC_ServerAppServer_getFromTableDatbaseByProperty(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        tyStringSequence iceP_paReturnId;
        ::std::string iceP_paReturnMessage;
        bool ret;
        try
        {
            ret = proxy->end_getFromTableDatbaseByProperty(iceP_paReturnId, iceP_paReturnMessage, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_paReturnId, iceP_paReturnMessage);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getFromTableDatbaseByProperty.
 */
template<class T> Callback_ServerAppServer_getFromTableDatbaseByPropertyPtr
newCallback_ServerAppServer_getFromTableDatbaseByProperty(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const tyStringSequence&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_getFromTableDatbaseByProperty<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getFromTableDatbaseByProperty.
 */
template<class T> Callback_ServerAppServer_getFromTableDatbaseByPropertyPtr
newCallback_ServerAppServer_getFromTableDatbaseByProperty(T* instance, void (T::*cb)(bool, const tyStringSequence&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_getFromTableDatbaseByProperty<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_getFromTableDatbaseByProperty.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_getFromTableDatbaseByProperty.
 */
template<class T, typename CT>
class Callback_ServerAppServer_getFromTableDatbaseByProperty : public Callback_ServerAppServer_getFromTableDatbaseByProperty_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const tyStringSequence&, const ::std::string&, const CT&);

    Callback_ServerAppServer_getFromTableDatbaseByProperty(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        tyStringSequence iceP_paReturnId;
        ::std::string iceP_paReturnMessage;
        bool ret;
        try
        {
            ret = proxy->end_getFromTableDatbaseByProperty(iceP_paReturnId, iceP_paReturnMessage, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_paReturnId, iceP_paReturnMessage, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getFromTableDatbaseByProperty.
 */
template<class T, typename CT> Callback_ServerAppServer_getFromTableDatbaseByPropertyPtr
newCallback_ServerAppServer_getFromTableDatbaseByProperty(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const tyStringSequence&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_getFromTableDatbaseByProperty<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getFromTableDatbaseByProperty.
 */
template<class T, typename CT> Callback_ServerAppServer_getFromTableDatbaseByPropertyPtr
newCallback_ServerAppServer_getFromTableDatbaseByProperty(T* instance, void (T::*cb)(bool, const tyStringSequence&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_getFromTableDatbaseByProperty<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_getFromTableDatabaseById.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_getFromTableDatabaseById.
 */
template<class T>
class CallbackNC_ServerAppServer_getFromTableDatabaseById : public Callback_ServerAppServer_getFromTableDatabaseById_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const tyStringSequence&, const ::std::string&);

    CallbackNC_ServerAppServer_getFromTableDatabaseById(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        tyStringSequence iceP_paReturnValue;
        ::std::string iceP_paReturnMessage;
        bool ret;
        try
        {
            ret = proxy->end_getFromTableDatabaseById(iceP_paReturnValue, iceP_paReturnMessage, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_paReturnValue, iceP_paReturnMessage);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getFromTableDatabaseById.
 */
template<class T> Callback_ServerAppServer_getFromTableDatabaseByIdPtr
newCallback_ServerAppServer_getFromTableDatabaseById(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const tyStringSequence&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_getFromTableDatabaseById<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getFromTableDatabaseById.
 */
template<class T> Callback_ServerAppServer_getFromTableDatabaseByIdPtr
newCallback_ServerAppServer_getFromTableDatabaseById(T* instance, void (T::*cb)(bool, const tyStringSequence&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_getFromTableDatabaseById<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_getFromTableDatabaseById.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_getFromTableDatabaseById.
 */
template<class T, typename CT>
class Callback_ServerAppServer_getFromTableDatabaseById : public Callback_ServerAppServer_getFromTableDatabaseById_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const tyStringSequence&, const ::std::string&, const CT&);

    Callback_ServerAppServer_getFromTableDatabaseById(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        tyStringSequence iceP_paReturnValue;
        ::std::string iceP_paReturnMessage;
        bool ret;
        try
        {
            ret = proxy->end_getFromTableDatabaseById(iceP_paReturnValue, iceP_paReturnMessage, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_paReturnValue, iceP_paReturnMessage, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getFromTableDatabaseById.
 */
template<class T, typename CT> Callback_ServerAppServer_getFromTableDatabaseByIdPtr
newCallback_ServerAppServer_getFromTableDatabaseById(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const tyStringSequence&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_getFromTableDatabaseById<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getFromTableDatabaseById.
 */
template<class T, typename CT> Callback_ServerAppServer_getFromTableDatabaseByIdPtr
newCallback_ServerAppServer_getFromTableDatabaseById(T* instance, void (T::*cb)(bool, const tyStringSequence&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_getFromTableDatabaseById<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_getAllTablesFromDatabase.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_getAllTablesFromDatabase.
 */
template<class T>
class CallbackNC_ServerAppServer_getAllTablesFromDatabase : public Callback_ServerAppServer_getAllTablesFromDatabase_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const tyStringSequence&, const ::std::string&);

    CallbackNC_ServerAppServer_getAllTablesFromDatabase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        tyStringSequence iceP_paTables;
        ::std::string iceP_paReturnMessage;
        bool ret;
        try
        {
            ret = proxy->end_getAllTablesFromDatabase(iceP_paTables, iceP_paReturnMessage, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_paTables, iceP_paReturnMessage);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getAllTablesFromDatabase.
 */
template<class T> Callback_ServerAppServer_getAllTablesFromDatabasePtr
newCallback_ServerAppServer_getAllTablesFromDatabase(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const tyStringSequence&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_getAllTablesFromDatabase<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getAllTablesFromDatabase.
 */
template<class T> Callback_ServerAppServer_getAllTablesFromDatabasePtr
newCallback_ServerAppServer_getAllTablesFromDatabase(T* instance, void (T::*cb)(bool, const tyStringSequence&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_getAllTablesFromDatabase<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_getAllTablesFromDatabase.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_getAllTablesFromDatabase.
 */
template<class T, typename CT>
class Callback_ServerAppServer_getAllTablesFromDatabase : public Callback_ServerAppServer_getAllTablesFromDatabase_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const tyStringSequence&, const ::std::string&, const CT&);

    Callback_ServerAppServer_getAllTablesFromDatabase(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        tyStringSequence iceP_paTables;
        ::std::string iceP_paReturnMessage;
        bool ret;
        try
        {
            ret = proxy->end_getAllTablesFromDatabase(iceP_paTables, iceP_paReturnMessage, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_paTables, iceP_paReturnMessage, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getAllTablesFromDatabase.
 */
template<class T, typename CT> Callback_ServerAppServer_getAllTablesFromDatabasePtr
newCallback_ServerAppServer_getAllTablesFromDatabase(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const tyStringSequence&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_getAllTablesFromDatabase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getAllTablesFromDatabase.
 */
template<class T, typename CT> Callback_ServerAppServer_getAllTablesFromDatabasePtr
newCallback_ServerAppServer_getAllTablesFromDatabase(T* instance, void (T::*cb)(bool, const tyStringSequence&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_getAllTablesFromDatabase<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_getAllMethodsFromTable.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_getAllMethodsFromTable.
 */
template<class T>
class CallbackNC_ServerAppServer_getAllMethodsFromTable : public Callback_ServerAppServer_getAllMethodsFromTable_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const ::std::string&);

    CallbackNC_ServerAppServer_getAllMethodsFromTable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        tyStringSequence iceP_paMethodName;
        tyStringSequence iceP_paAlias;
        tyStringSequence iceP_paSource;
        tyStringSequence iceP_paSourceName;
        tyStringSequence iceP_paReturnType;
        ::std::string iceP_paReturnMessage;
        bool ret;
        try
        {
            ret = proxy->end_getAllMethodsFromTable(iceP_paMethodName, iceP_paAlias, iceP_paSource, iceP_paSourceName, iceP_paReturnType, iceP_paReturnMessage, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_paMethodName, iceP_paAlias, iceP_paSource, iceP_paSourceName, iceP_paReturnType, iceP_paReturnMessage);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getAllMethodsFromTable.
 */
template<class T> Callback_ServerAppServer_getAllMethodsFromTablePtr
newCallback_ServerAppServer_getAllMethodsFromTable(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_getAllMethodsFromTable<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getAllMethodsFromTable.
 */
template<class T> Callback_ServerAppServer_getAllMethodsFromTablePtr
newCallback_ServerAppServer_getAllMethodsFromTable(T* instance, void (T::*cb)(bool, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_getAllMethodsFromTable<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_getAllMethodsFromTable.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_getAllMethodsFromTable.
 */
template<class T, typename CT>
class Callback_ServerAppServer_getAllMethodsFromTable : public Callback_ServerAppServer_getAllMethodsFromTable_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const ::std::string&, const CT&);

    Callback_ServerAppServer_getAllMethodsFromTable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        tyStringSequence iceP_paMethodName;
        tyStringSequence iceP_paAlias;
        tyStringSequence iceP_paSource;
        tyStringSequence iceP_paSourceName;
        tyStringSequence iceP_paReturnType;
        ::std::string iceP_paReturnMessage;
        bool ret;
        try
        {
            ret = proxy->end_getAllMethodsFromTable(iceP_paMethodName, iceP_paAlias, iceP_paSource, iceP_paSourceName, iceP_paReturnType, iceP_paReturnMessage, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_paMethodName, iceP_paAlias, iceP_paSource, iceP_paSourceName, iceP_paReturnType, iceP_paReturnMessage, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getAllMethodsFromTable.
 */
template<class T, typename CT> Callback_ServerAppServer_getAllMethodsFromTablePtr
newCallback_ServerAppServer_getAllMethodsFromTable(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_getAllMethodsFromTable<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getAllMethodsFromTable.
 */
template<class T, typename CT> Callback_ServerAppServer_getAllMethodsFromTablePtr
newCallback_ServerAppServer_getAllMethodsFromTable(T* instance, void (T::*cb)(bool, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_getAllMethodsFromTable<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_getAllPropertiesFromTable.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_getAllPropertiesFromTable.
 */
template<class T>
class CallbackNC_ServerAppServer_getAllPropertiesFromTable : public Callback_ServerAppServer_getAllPropertiesFromTable_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const ::std::string&);

    CallbackNC_ServerAppServer_getAllPropertiesFromTable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        tyStringSequence iceP_paPropertyName;
        tyStringSequence iceP_paAlias;
        tyStringSequence iceP_paType;
        tyStringSequence iceP_paExtra;
        tyStringSequence iceP_paReference;
        ::std::string iceP_paReturnMessage;
        bool ret;
        try
        {
            ret = proxy->end_getAllPropertiesFromTable(iceP_paPropertyName, iceP_paAlias, iceP_paType, iceP_paExtra, iceP_paReference, iceP_paReturnMessage, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_paPropertyName, iceP_paAlias, iceP_paType, iceP_paExtra, iceP_paReference, iceP_paReturnMessage);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getAllPropertiesFromTable.
 */
template<class T> Callback_ServerAppServer_getAllPropertiesFromTablePtr
newCallback_ServerAppServer_getAllPropertiesFromTable(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_getAllPropertiesFromTable<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getAllPropertiesFromTable.
 */
template<class T> Callback_ServerAppServer_getAllPropertiesFromTablePtr
newCallback_ServerAppServer_getAllPropertiesFromTable(T* instance, void (T::*cb)(bool, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_getAllPropertiesFromTable<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_getAllPropertiesFromTable.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_getAllPropertiesFromTable.
 */
template<class T, typename CT>
class Callback_ServerAppServer_getAllPropertiesFromTable : public Callback_ServerAppServer_getAllPropertiesFromTable_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const ::std::string&, const CT&);

    Callback_ServerAppServer_getAllPropertiesFromTable(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        tyStringSequence iceP_paPropertyName;
        tyStringSequence iceP_paAlias;
        tyStringSequence iceP_paType;
        tyStringSequence iceP_paExtra;
        tyStringSequence iceP_paReference;
        ::std::string iceP_paReturnMessage;
        bool ret;
        try
        {
            ret = proxy->end_getAllPropertiesFromTable(iceP_paPropertyName, iceP_paAlias, iceP_paType, iceP_paExtra, iceP_paReference, iceP_paReturnMessage, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_paPropertyName, iceP_paAlias, iceP_paType, iceP_paExtra, iceP_paReference, iceP_paReturnMessage, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getAllPropertiesFromTable.
 */
template<class T, typename CT> Callback_ServerAppServer_getAllPropertiesFromTablePtr
newCallback_ServerAppServer_getAllPropertiesFromTable(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_getAllPropertiesFromTable<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_getAllPropertiesFromTable.
 */
template<class T, typename CT> Callback_ServerAppServer_getAllPropertiesFromTablePtr
newCallback_ServerAppServer_getAllPropertiesFromTable(T* instance, void (T::*cb)(bool, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const tyStringSequence&, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_getAllPropertiesFromTable<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_giveWorkstationClientInfo.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_giveWorkstationClientInfo.
 */
template<class T>
class CallbackNC_ServerAppServer_giveWorkstationClientInfo : public Callback_ServerAppServer_giveWorkstationClientInfo_Base, public ::IceInternal::TwowayCallbackNC<T>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception&);
    typedef void (T::*Sent)(bool);
    typedef void (T::*Response)(bool, const ::std::string&);

    CallbackNC_ServerAppServer_giveWorkstationClientInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallbackNC<T>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_paReturnMessage;
        bool ret;
        try
        {
            ret = proxy->end_giveWorkstationClientInfo(iceP_paReturnMessage, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::CallbackNC<T>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::CallbackNC<T>::_callback.get()->*_response)(ret, iceP_paReturnMessage);
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_giveWorkstationClientInfo.
 */
template<class T> Callback_ServerAppServer_giveWorkstationClientInfoPtr
newCallback_ServerAppServer_giveWorkstationClientInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_giveWorkstationClientInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_giveWorkstationClientInfo.
 */
template<class T> Callback_ServerAppServer_giveWorkstationClientInfoPtr
newCallback_ServerAppServer_giveWorkstationClientInfo(T* instance, void (T::*cb)(bool, const ::std::string&), void (T::*excb)(const ::Ice::Exception&), void (T::*sentcb)(bool) = 0)
{
    return new CallbackNC_ServerAppServer_giveWorkstationClientInfo<T>(instance, cb, excb, sentcb);
}

/**
 * Type-safe asynchronous callback wrapper class with cookie support used for calls to
 * IceProxy::UVServerAppServer::ServerAppServer::begin_giveWorkstationClientInfo.
 * Create a wrapper instance by calling ::UVServerAppServer::newCallback_ServerAppServer_giveWorkstationClientInfo.
 */
template<class T, typename CT>
class Callback_ServerAppServer_giveWorkstationClientInfo : public Callback_ServerAppServer_giveWorkstationClientInfo_Base, public ::IceInternal::TwowayCallback<T, CT>
{
public:

    typedef IceUtil::Handle<T> TPtr;

    typedef void (T::*Exception)(const ::Ice::Exception& , const CT&);
    typedef void (T::*Sent)(bool , const CT&);
    typedef void (T::*Response)(bool, const ::std::string&, const CT&);

    Callback_ServerAppServer_giveWorkstationClientInfo(const TPtr& obj, Response cb, Exception excb, Sent sentcb)
        : ::IceInternal::TwowayCallback<T, CT>(obj, cb != 0, excb, sentcb), _response(cb)
    {
    }

    /// \cond INTERNAL
    virtual void completed(const ::Ice::AsyncResultPtr& result) const
    {
        ServerAppServerPrx proxy = ServerAppServerPrx::uncheckedCast(result->getProxy());
        ::std::string iceP_paReturnMessage;
        bool ret;
        try
        {
            ret = proxy->end_giveWorkstationClientInfo(iceP_paReturnMessage, result);
        }
        catch(const ::Ice::Exception& ex)
        {
            ::IceInternal::Callback<T, CT>::exception(result, ex);
            return;
        }
        if(_response)
        {
            (::IceInternal::Callback<T, CT>::_callback.get()->*_response)(ret, iceP_paReturnMessage, CT::dynamicCast(result->getCookie()));
        }
    }
    /// \endcond

private:

    Response _response;
};

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_giveWorkstationClientInfo.
 */
template<class T, typename CT> Callback_ServerAppServer_giveWorkstationClientInfoPtr
newCallback_ServerAppServer_giveWorkstationClientInfo(const IceUtil::Handle<T>& instance, void (T::*cb)(bool, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_giveWorkstationClientInfo<T, CT>(instance, cb, excb, sentcb);
}

/**
 * Creates a callback wrapper instance that delegates to your object.
 * Use this overload when your callback methods receive a cookie value.
 * @param instance The callback object.
 * @param cb The success method of the callback object.
 * @param excb The exception method of the callback object.
 * @param sentcb The sent method of the callback object.
 * @return An object that can be passed to an asynchronous invocation of IceProxy::UVServerAppServer::ServerAppServer::begin_giveWorkstationClientInfo.
 */
template<class T, typename CT> Callback_ServerAppServer_giveWorkstationClientInfoPtr
newCallback_ServerAppServer_giveWorkstationClientInfo(T* instance, void (T::*cb)(bool, const ::std::string&, const CT&), void (T::*excb)(const ::Ice::Exception&, const CT&), void (T::*sentcb)(bool, const CT&) = 0)
{
    return new Callback_ServerAppServer_giveWorkstationClientInfo<T, CT>(instance, cb, excb, sentcb);
}

}

#endif

#include <IceUtil/PopDisableWarnings.h>
#endif
